<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Academic Reference Checker</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
const { useState } = React;

const ReferenceChecker = () => {
  const [document, setDocument] = useState('');
  const [results, setResults] = useState(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [secondAnalysis, setSecondAnalysis] = useState(null);
  const [isSecondAnalysisRunning, setIsSecondAnalysisRunning] = useState(false);
  const [isVerifying, setIsVerifying] = useState(false);
  const [verificationResults, setVerificationResults] = useState(null);
  const [showExportData, setShowExportData] = useState(false);

  const normalize = (text) => text.toLowerCase().replace(/[.,&]/g, '').replace(/\s+et\s+al\.?/g, '').replace(/[-\s]+/g, ' ').replace(/\s+/g, ' ').trim();
  const extractFirstAuthor = (authorString) => authorString.split(/\s*[&,]\s*/)[0].replace(/\s+et\s+al\.?/i, '').trim();

  const extractCitations = (text) => {
    const citations = [];
    const foundCitations = new Set();

    const pattern = /\([^)]*[A-Z][A-Za-z\-\']*(?:\s*-\s*[A-Za-z\-\']+)*(?:\s+et\s+al\.?)?.*?\d{4}[^)]*\)/g;
    const matches = text.match(pattern) || [];

    matches.forEach(match => {
      const cleaned = match.replace(/[()]/g, '');
      const groups = cleaned.split(';');

      groups.forEach(group => {
        group = group.trim();
        const authorYearMatch = group.match(/^([A-Za-z\-\'\s,&]+?)\s*,?\s*(\d{4})/);

        if (authorYearMatch) {
          let authors = authorYearMatch[1].trim()
            .replace(/^(e\.g\.,|see|cf\.)\s*/i, '')
            .replace(/,?\s*p\.\s*\d+.*$/, '')
            .replace(/\s*,\s*$/, '').trim();
          const year = authorYearMatch[2];
          const citationKey = normalize(authors + ' ' + year);

          if (!foundCitations.has(citationKey)) {
            citations.push({
              original: '(' + group.trim() + ')',
              authors: authors,
              year: year,
              normalized: citationKey,
              type: 'parenthetical'
            });
            foundCitations.add(citationKey);
          }
        }
      });
    });

    const narrativePattern = /\b([A-Z][A-Za-z\-\']*(?:\s*-\s*[A-Za-z\-\']+)*(?:\s+et\s+al\.?)?(?:'s)?)\s+\((\d{4})\)/g;
    let narrativeMatch;
    while ((narrativeMatch = narrativePattern.exec(text)) !== null) {
      const leadAuthor = narrativeMatch[1].replace(/'s$/, '');
      const year = narrativeMatch[2];
      const citationKey = normalize(leadAuthor + ' ' + year);

      if (!foundCitations.has(citationKey)) {
        citations.push({
          original: leadAuthor + ' (' + year + ')',
          authors: leadAuthor,
          year: year,
          normalized: citationKey,
          type: 'narrative'
        });
        foundCitations.add(citationKey);
      }
    }

    return citations;
  };

  const extractReferences = (text) => {
    const refSectionMatch = text.match(/(References|Bibliography|Works Cited)\s*\n([\s\S]*?)(?:\n\n[A-Z]|\n*$)/i);
    if (!refSectionMatch) return [];

    const refSection = refSectionMatch[2];
    const refLines = refSection.split('\n').filter(line => line.trim().length > 20);
    const references = [];

    refLines.forEach(line => {
      const yearMatch = line.match(/\((\d{4})\)/);
      if (!yearMatch) return;

      const year = yearMatch[1];
      const beforeYear = line.substring(0, line.indexOf('(' + year + ')')).trim();
      const firstCommaIndex = beforeYear.indexOf(',');
      const firstAuthor = firstCommaIndex !== -1 ? beforeYear.substring(0, firstCommaIndex).trim() : beforeYear;
      const allAuthors = beforeYear.replace(/\([^)]*\)/g, '').replace(/\.$/, '').trim();

      references.push({
        original: line.trim(),
        firstAuthor: firstAuthor,
        allAuthors: allAuthors,
        year: year,
        normalized: normalize(allAuthors + ' ' + year),
        firstAuthorNormalized: normalize(firstAuthor + ' ' + year)
      });
    });

    return references;
  };

  const matchCitationsToReferences = (citations, references) => {
    const fullMatches = [];
    const partialMatches = [];
    const unmatched = [];
    const usedReferences = new Set();

    citations.forEach((citation) => {
      let bestMatch = null;
      let bestScore = 0;

      references.forEach((ref, refIndex) => {
        if (citation.year !== ref.year) return;

        const citationAuthorsNorm = normalize(citation.authors);
        const refAllAuthorsNorm = normalize(ref.allAuthors);
        const citationFirstAuthor = normalize(extractFirstAuthor(citation.authors));
        const refFirstAuthor = normalize(extractFirstAuthor(ref.firstAuthor));

        let score = 0;
        let matchType = 'none';

        if (citation.normalized === ref.normalized || citation.normalized === ref.firstAuthorNormalized) {
          score = 100;
          matchType = 'full';
        } else if (citationAuthorsNorm === refAllAuthorsNorm) {
          score = 100;
          matchType = 'full';
        } else if (citationFirstAuthor === refFirstAuthor && citationFirstAuthor.length > 2) {
          score = 90;
          matchType = 'partial';
        }

        if (score > bestScore) {
          bestScore = score;
          bestMatch = { reference: ref, index: refIndex, confidence: score, matchType };
        }
      });

      if (bestMatch && bestMatch.confidence >= 85) {
        const matchData = {
          citation: citation,
          reference: bestMatch.reference,
          confidence: bestMatch.confidence,
          matchType: bestMatch.matchType
        };

        if (bestMatch.matchType === 'full') {
          fullMatches.push(matchData);
        } else {
          partialMatches.push(matchData);
        }

        usedReferences.add(bestMatch.index);
      } else {
        unmatched.push({ citation: citation, suggestions: [] });
      }
    });

    const unusedReferences = references
      .filter((ref, index) => !usedReferences.has(index))
      .map(ref => ({ reference: ref, possibleMatches: [] }));

    return { fullMatches, partialMatches, unmatched, unusedReferences };
  };

  const performSecondAnalysis = (unusedRefs, documentText) => {
    const suggestions = [];

    unusedRefs.forEach(unusedRef => {
      const ref = unusedRef.reference;
      const refFirstAuthor = extractFirstAuthor(ref.firstAuthor).toLowerCase();
      const refYear = ref.year;
      const candidates = [];

      const authorVariations = [
        refFirstAuthor,
        refFirstAuthor.charAt(0).toUpperCase() + refFirstAuthor.slice(1),
        ref.firstAuthor.split(',')[0].toLowerCase().trim(),
        ref.firstAuthor.split(',')[0].trim()
      ];

      if (refFirstAuthor.includes('-')) {
        const parts = refFirstAuthor.split('-');
        authorVariations.push(parts[0]);
        authorVariations.push(parts[0].charAt(0).toUpperCase() + parts[0].slice(1));
      }

      authorVariations.forEach(authorVar => {
        if (authorVar.length < 3) return;

        const escapedAuthor = authorVar.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        try {
          const narrativeRegex = new RegExp('\\b' + escapedAuthor + '[A-Za-z\\-]*(?:\\s+et\\s+al\\.?)?(?:\'s)?\\s*\\(' + refYear + '\\)', 'gi');
          let match;
          while ((match = narrativeRegex.exec(documentText)) !== null) {
            candidates.push({ text: match[0], position: match.index, confidence: 0.9, type: 'narrative' });
          }

          const parentheticalRegex = new RegExp('\\([^)]*' + escapedAuthor + '[^)]*' + refYear + '[^)]*\\)', 'gi');
          while ((match = parentheticalRegex.exec(documentText)) !== null) {
            candidates.push({ text: match[0], position: match.index, confidence: 0.8, type: 'parenthetical' });
          }
        } catch (e) {
          // Skip if regex fails
        }
      });

      const uniqueCandidates = candidates
        .filter((candidate, index, arr) => arr.findIndex(c => c.text === candidate.text) === index)
        .sort((a, b) => b.confidence - a.confidence)
        .slice(0, 3);

      if (uniqueCandidates.length > 0) {
        suggestions.push({ reference: ref, candidates: uniqueCandidates });
      }
    });

    return suggestions;
  };

  const runSecondAnalysis = () => {
    if (!results || !results.unused.length) return;
    setIsSecondAnalysisRunning(true);

    setTimeout(() => {
      const suggestions = performSecondAnalysis(results.unused, document);
      setSecondAnalysis(suggestions);
      setIsSecondAnalysisRunning(false);
    }, 1000);
  };

  const markAsMatch = (refIndex, candidateText) => {
    if (!secondAnalysis) return;

    const updatedAnalysis = secondAnalysis.map((suggestion, index) => {
      if (index === refIndex) {
        return { ...suggestion, confirmedMatch: candidateText, confirmed: true };
      }
      return suggestion;
    });

    setSecondAnalysis(updatedAnalysis);
  };

  const updateResults = () => {
    if (!secondAnalysis || !results) return;

    const confirmedMatches = secondAnalysis.filter(s => s.confirmed);
    if (confirmedMatches.length === 0) return;

    const newPartialMatches = [];
    const confirmedRefs = new Set();
    const matchedMissingIndices = new Set();

    confirmedMatches.forEach(suggestion => {
      let bestMissingMatch = null;
      let bestScore = 0;
      let bestIndex = -1;

      results.missing.forEach((missing, index) => {
        const refYear = suggestion.reference.year;
        let score = 0;

        if (missing.citation.year === refYear) {
          score += 50;
          const missingAuthor = missing.citation.authors.toLowerCase();
          const refFirstAuthor = extractFirstAuthor(suggestion.reference.firstAuthor).toLowerCase();

          if (missingAuthor.includes(refFirstAuthor) || refFirstAuthor.includes(missingAuthor)) {
            score += 40;
          }
        }

        if (score > bestScore && score > 60) {
          bestScore = score;
          bestMissingMatch = missing;
          bestIndex = index;
        }
      });

      const newMatch = {
        citation: bestMissingMatch ? bestMissingMatch.citation : {
          original: suggestion.confirmedMatch,
          authors: extractFirstAuthor(suggestion.reference.firstAuthor),
          year: suggestion.reference.year,
          normalized: normalize(extractFirstAuthor(suggestion.reference.firstAuthor) + ' ' + suggestion.reference.year),
          type: 'confirmed'
        },
        reference: suggestion.reference,
        confidence: 'User Confirmed',
        matchType: 'user_confirmed'
      };

      newPartialMatches.push(newMatch);
      confirmedRefs.add(suggestion.reference);

      if (bestIndex !== -1) {
        matchedMissingIndices.add(bestIndex);
      }
    });

    const updatedUnused = results.unused.filter(u => !confirmedRefs.has(u.reference));
    const updatedMissing = results.missing.filter((missing, index) => !matchedMissingIndices.has(index));

    const updatedResults = {
      ...results,
      partialMatches: [...results.partialMatches, ...newPartialMatches],
      unused: updatedUnused,
      missing: updatedMissing,
      summary: {
        ...results.summary,
        partialMatches: results.summary.partialMatches + newPartialMatches.length,
        missingReferences: updatedMissing.length,
        unusedReferences: updatedUnused.length,
        matchRate: results.summary.totalCitations > 0 ?
          (((results.summary.fullMatches + results.summary.partialMatches + newPartialMatches.length) / results.summary.totalCitations) * 100).toFixed(1) + '%' : '0%'
      }
    };

    setResults(updatedResults);
    setSecondAnalysis(secondAnalysis.filter(s => !s.confirmed));
  };

  const verifyReferences = async () => {
    if (!results) return;
    setIsVerifying(true);

    const allReferences = [...results.fullMatches.map(m => m.reference), ...results.partialMatches.map(m => m.reference), ...results.unused.map(u => u.reference)];
    const newVerificationResults = {};

    for (const ref of allReferences) {
      try {
        // This now calls our serverless function endpoint
        const response = await fetch('/.netlify/functions/verify', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ referenceText: ref.original }),
        });

        if (response.ok) {
          const result = await response.json();
          newVerificationResults[ref.original] = result;
        } else {
          const errorText = await response.text();
          newVerificationResults[ref.original] = { status: 'Error', details: `Verification failed: ${errorText}` };
        }
      } catch (error) {
        newVerificationResults[ref.original] = { status: 'Error', details: `Could not connect to verification service: ${error.message}` };
      }
      // Update state after each check to show progress
      setVerificationResults({...newVerificationResults});
    }

    setIsVerifying(false);
  };

  const showActualData = () => {
    setShowExportData(!showExportData);
  };

  const processDocument = () => {
    if (!document.trim()) return;

    setIsProcessing(true);
    setSecondAnalysis(null);
    setVerificationResults(null);

    setTimeout(() => {
      const citations = extractCitations(document);
      const references = extractReferences(document);
      const matchResults = matchCitationsToReferences(citations, references);

      const summary = {
        totalCitations: citations.length,
        totalReferences: references.length,
        fullMatches: matchResults.fullMatches.length,
        partialMatches: matchResults.partialMatches.length,
        missingReferences: matchResults.unmatched.length,
        unusedReferences: matchResults.unusedReferences.length,
        matchRate: citations.length > 0 ?
          (((matchResults.fullMatches.length + matchResults.partialMatches.length) / citations.length) * 100).toFixed(1) + '%' : '0%'
      };

      setResults({
        summary,
        fullMatches: matchResults.fullMatches,
        partialMatches: matchResults.partialMatches,
        missing: matchResults.unmatched,
        unused: matchResults.unusedReferences
      });

      setIsProcessing(false);
    }, 1500);
  };

  const getConfidenceBadge = (confidence) => {
    if (confidence === 'User Confirmed') return 'bg-blue-100 text-blue-800';
    if (confidence >= 90) return 'bg-green-100 text-green-800';
    if (confidence >= 70) return 'bg-yellow-100 text-yellow-800';
    return 'bg-red-100 text-red-800';
  };

  const getConfidenceColor = (confidence) => {
    if (confidence >= 0.8) return 'text-green-600';
    if (confidence >= 0.6) return 'text-yellow-600';
    return 'text-red-600';
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
      <div className="max-w-6xl mx-auto">
        <div className="text-center mb-8">
          <div className="flex items-center justify-center mb-4">
            <div className="text-5xl text-indigo-600 mr-3">üìÑ</div>
            <h1 className="text-4xl font-bold text-gray-800">Academic Reference Checker</h1>
          </div>
          <p className="text-lg text-gray-600">
            Automatically verify citations and reference lists in academic documents
          </p>
        </div>

        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
          <div className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Document Text
            </label>
            <textarea
              value={document}
              onChange={(e) => setDocument(e.target.value)}
              placeholder="Paste your academic document here... Try testing with: (Gouda-Vossos et al., 2019)"
              className="w-full h-64 p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none"
            />
          </div>

          <button
            onClick={processDocument}
            disabled={!document.trim() || isProcessing}
            className="w-full bg-indigo-600 text-white py-3 px-6 rounded-lg hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors flex items-center justify-center space-x-2"
          >
            {isProcessing ? (
              <>
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                <span>Processing Document...</span>
              </>
            ) : (
              <>
                <span className="text-xl">üîç</span>
                <span>Analyze References</span>
              </>
            )}
          </button>
        </div>

        {results && (
          <div className="space-y-6">
            <div className="bg-white rounded-xl shadow-lg p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-2xl font-bold text-gray-800">Analysis Summary</h2>
                <div className="flex space-x-2">
                  {results.unused.length > 0 && !secondAnalysis && (
                    <button
                      onClick={runSecondAnalysis}
                      disabled={isSecondAnalysisRunning}
                      className="flex items-center space-x-2 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 disabled:bg-gray-400 transition-colors"
                    >
                      {isSecondAnalysisRunning ? (
                        <>
                          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                          <span>Analyzing...</span>
                        </>
                      ) : (
                        <>
                          <span className="text-lg">üîÑ</span>
                          <span>Find More Matches</span>
                        </>
                      )}
                    </button>
                  )}
                  <button
                    onClick={verifyReferences}
                    disabled={isVerifying}
                    className="flex items-center space-x-2 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 disabled:bg-gray-400 transition-colors"
                  >
                    {isVerifying ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                        <span>Verifying...</span>
                      </>
                    ) : (
                      <>
                        <span className="text-lg">‚úÖ</span>
                        <span>Verify Online</span>
                      </>
                    )}
                  </button>
                  <button
                    onClick={showActualData}
                    className="flex items-center space-x-2 bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    <span className="text-lg">üì•</span>
                    <span>{showExportData ? 'Hide' : 'Show'} Raw Data</span>
                  </button>
                </div>
              </div>

              <div className="grid grid-cols-2 md:grid-cols-6 gap-4 mb-6">
                <div className="bg-blue-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-blue-600">{results.summary.totalCitations}</div>
                  <div className="text-sm text-gray-600">Total Citations</div>
                </div>
                <div className="bg-emerald-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-emerald-600">{results.summary.fullMatches}</div>
                  <div className="text-sm text-gray-600">Full Matches</div>
                </div>
                <div className="bg-green-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-green-600">{results.summary.partialMatches}</div>
                  <div className="text-sm text-gray-600">Partial Matches</div>
                </div>
                <div className="bg-red-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-red-600">{results.summary.missingReferences}</div>
                  <div className="text-sm text-gray-600">Missing Refs</div>
                </div>
                <div className="bg-orange-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-orange-600">{results.summary.unusedReferences}</div>
                  <div className="text-sm text-gray-600">Unused Refs</div>
                </div>
                <div className="bg-purple-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-purple-600">{results.summary.matchRate}</div>
                  <div className="text-sm text-gray-600">Match Rate</div>
                </div>
              </div>
            </div>

            {showExportData && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <h3 className="text-xl font-bold text-gray-800 mb-4">Raw Data - Copy What You Need</h3>

                <div className="space-y-6">
                  <div>
                    <h4 className="text-lg font-semibold text-gray-700 mb-2">JSON Data:</h4>
                    <div className="bg-gray-100 p-4 rounded text-xs overflow-auto max-h-64">
                      <pre>{JSON.stringify({
                        summary: results.summary,
                        fullMatches: results.fullMatches,
                        partialMatches: results.partialMatches,
                        missingReferences: results.missing,
                        unusedReferences: results.unused,
                        verificationResults: verificationResults || {}
                      }, null, 2)}</pre>
                    </div>
                  </div>

                  <div>
                    <h4 className="text-lg font-semibold text-gray-700 mb-2">HTML Report Template:</h4>
                    <div className="bg-gray-100 p-4 rounded text-xs overflow-auto max-h-64">
                      <pre>{`<!DOCTYPE html>
<html>
<head>
    <title>Reference Check Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #1e40af; }
        .citation { background: #f9fafb; border-left: 4px solid #6b7280; padding: 15px; margin: 10px 0; }
        .full-match { border-left-color: #10b981; }
        .partial-match { border-left-color: #22c55e; }
        .user-confirmed { border-left-color: #3b82f6; }
        .missing { border-left-color: #ef4444; }
        .unused { border-left-color: #f59e0b; }
    </style>
</head>
<body>
    <h1>Academic Reference Check Report</h1>
    <p>Total Citations: ${results.summary.totalCitations}</p>
    <p>Full Matches: ${results.summary.fullMatches}</p>
    <p>Partial Matches: ${results.summary.partialMatches}</p>
    <p>Missing: ${results.summary.missingReferences}</p>
    <p>Unused: ${results.summary.unusedReferences}</p>
    <p>Match Rate: ${results.summary.matchRate}</p>
    <!-- Add your matches here -->
</body>
</html>`}</pre>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {secondAnalysis && secondAnalysis.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center">
                    <span className="text-2xl text-purple-500 mr-2">üîÑ</span>
                    <h3 className="text-xl font-bold text-gray-800">Potential Matches Found ({secondAnalysis.length})</h3>
                  </div>
                  {secondAnalysis.some(s => s.confirmed) && (
                    <button
                      onClick={updateResults}
                      className="flex items-center space-x-2 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors"
                    >
                      <span className="text-lg">‚úÖ</span>
                      <span>Update Results ({secondAnalysis.filter(s => s.confirmed).length})</span>
                    </button>
                  )}
                </div>
                <div className="space-y-4">
                  {secondAnalysis.map((suggestion, index) => (
                    <div key={index} className={suggestion.confirmed ? 'border rounded-lg p-4 bg-green-50 border-green-200' : 'border rounded-lg p-4 bg-purple-50 border-purple-200'}>
                      <div className="font-semibold text-gray-800 mb-2">
                        Reference: {suggestion.reference.original.substring(0, 100)}...
                      </div>
                      {suggestion.confirmed ? (
                        <div className="text-green-600 font-medium">
                          ‚úì Confirmed match: {suggestion.confirmedMatch}
                        </div>
                      ) : (
                        <div>
                          <div className="text-sm font-medium text-gray-700 mb-2">Potential citations found:</div>
                          {suggestion.candidates.map((candidate, candIndex) => (
                            <div key={candIndex} className="mb-2 p-2 bg-white border rounded">
                              <div className="flex items-center justify-between">
                                <div className="flex-1">
                                  <div className="text-sm font-mono bg-gray-100 p-2 rounded">
                                    {candidate.text}
                                  </div>
                                  <div className={`text-xs mt-1 ${getConfidenceColor(candidate.confidence)}`}>
                                    {Math.round(candidate.confidence * 100)}% confidence ‚Ä¢ {candidate.type}
                                  </div>
                                </div>
                                <button
                                  onClick={() => markAsMatch(index, candidate.text)}
                                  className="ml-4 px-3 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600 transition-colors"
                                >
                                  Mark as Match
                                </button>
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.missing.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <span className="text-2xl text-red-500 mr-2">‚ö†Ô∏è</span>
                  <h3 className="text-xl font-bold text-gray-800">Missing References ({results.missing.length})</h3>
                </div>
                <div className="space-y-4">
                  {results.missing.map((item, index) => (
                    <div key={index} className="border border-red-200 rounded-lg p-4 bg-red-50">
                      <div className="font-semibold text-red-800 mb-2">
                        Citation: {item.citation.original}
                      </div>
                      <div className="text-sm text-gray-600 mb-2">
                        Authors: {item.citation.authors} | Year: {item.citation.year}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.fullMatches.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <span className="text-2xl text-emerald-500 mr-2">‚úÖ</span>
                  <h3 className="text-xl font-bold text-gray-800">Full Matches ({results.fullMatches.length})</h3>
                </div>
                <div className="space-y-3">
                  {results.fullMatches.map((item, index) => (
                    <div key={index} className="border border-emerald-200 rounded-lg p-4 bg-emerald-50">
                      <div className="flex items-center justify-between">
                        <div className="flex-1">
                          <div className="font-semibold text-emerald-800">
                            Citation: {item.citation.original}
                          </div>
                          <div className="text-sm text-gray-600 mt-1">
                            Matches: {item.reference.original}
                          </div>
                          {verificationResults && verificationResults[item.reference.original] && (
                            <div className="mt-2 text-xs bg-blue-50 p-2 rounded">
                              <strong>Verification:</strong> {verificationResults[item.reference.original].status}
                              {verificationResults[item.reference.original].details && (
                                <div className="text-gray-600 mt-1">{verificationResults[item.reference.original].details}</div>
                              )}
                            </div>
                          )}
                        </div>
                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${getConfidenceBadge(item.confidence)}`}>
                          {item.confidence}% confidence
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.partialMatches.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <span className="text-2xl text-green-500 mr-2">‚úÖ</span>
                  <h3 className="text-xl font-bold text-gray-800">Partial Matches ({results.partialMatches.length})</h3>
                </div>
                <div className="space-y-3">
                  {results.partialMatches.map((item, index) => (
                    <div key={index} className="border border-green-200 rounded-lg p-4 bg-green-50">
                      <div className="flex items-center justify-between">
                        <div className="flex-1">
                          <div className="font-semibold text-green-800">
                            Citation: {item.citation.original}
                          </div>
                          <div className="text-sm text-gray-600 mt-1">
                            Matches: {item.reference.original}
                          </div>
                          {verificationResults && verificationResults[item.reference.original] && (
                            <div className="mt-2 text-xs bg-blue-50 p-2 rounded">
                              <strong>Verification:</strong> {verificationResults[item.reference.original].status}
                              {verificationResults[item.reference.original].details && (
                                <div className="text-gray-600 mt-1">{verificationResults[item.reference.original].details}</div>
                              )}
                            </div>
                          )}
                        </div>
                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${getConfidenceBadge(item.confidence)}`}>
                          {item.confidence === 'User Confirmed' ? 'User Confirmed' : `${item.confidence}% confidence`}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.unused.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <span className="text-2xl text-orange-500 mr-2">‚ö†Ô∏è</span>
                  <h3 className="text-xl font-bold text-gray-800">Unused References ({results.unused.length})</h3>
                </div>
                <div className="space-y-4">
                  {results.unused.map((item, index) => (
                    <div key={index} className="border border-orange-200 rounded-lg p-4 bg-orange-50">
                      <div className="font-semibold text-orange-800 mb-2">
                        {item.reference.original}
                      </div>
                      {verificationResults && verificationResults[item.reference.original] && (
                        <div className="text-xs bg-blue-50 p-2 rounded">
                          <strong>Verification:</strong> {verificationResults[item.reference.original].status}
                          {verificationResults[item.reference.original].details && (
                            <div className="text-gray-600 mt-1">{verificationResults[item.reference.original].details}</div>
                          )}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

ReactDOM.render(<ReferenceChecker />, document.getElementById('root'));
    </script>
</body>
</html>
