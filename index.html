<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Academic Reference Checker</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <script type="text/babel">
const { useState, useEffect } = React;

const ReferenceChecker = () => {
  const [document, setDocument] = useState('');
  const [results, setResults] = useState(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [secondAnalysis, setSecondAnalysis] = useState(null);
  const [thirdAnalysis, setThirdAnalysis] = useState(null);
  const [isSecondAnalysisRunning, setIsSecondAnalysisRunning] = useState(false);
  const [isThirdAnalysisRunning, setIsThirdAnalysisRunning] = useState(false);
  const [isVerifying, setIsVerifying] = useState(false);
  const [verificationResults, setVerificationResults] = useState(null);

  useEffect(() => {
    lucide.createIcons();
  });

  const normalize = (text) => {
    return text.toLowerCase()
      .replace(/[.,&()]/g, '')
      .replace(/\s*et\s+al\.?/g, '')
      .replace(/[-\s]+/g, ' ')
      .replace(/\s+/g, ' ')
      .replace(/\b(e\.g|see|cf)\b/g, '')
      .trim();
  };

  const extractFirstAuthor = (authorString) => {
    // Handle various author formats
    const cleaned = authorString.replace(/\s*et\s+al\.?/i, '').trim();
    const parts = cleaned.split(/\s*[&,]\s*/);
    return parts[0].replace(/\s+et\s+al\.?/i, '').trim();
  };

  const extractCitations = (text) => {
    const citations = [];
    const foundCitations = new Set();
    
    // MUCH MORE AGGRESSIVE: Extract ALL potential citation patterns
    
    // Pattern 1: Standard parenthetical (Author, Year) or (Author et al., Year)
    const parentheticalPattern1 = /\(([^)]*(?:[A-Z][a-zA-Z\-\']+[^)]*\d{4}[a-z]?[^)]*)+)\)/g;
    
    let match;
    while ((match = parentheticalPattern1.exec(text)) !== null) {
      const content = match[1].trim();
      
      // Skip if it looks like a page reference or other non-citation
      if (content.match(/^p\.|^pp\.|^page|^see p/i)) continue;
      if (content.match(/^\d+$/)) continue; // Just numbers
      if (content.length < 8) continue; // Too short to be a real citation
      
      // Split multiple citations by semicolon or comma if they have different years
      const parts = content.split(/[;,](?=\s*[A-Z])/);
      
      parts.forEach(part => {
        part = part.trim();
        if (part.length < 5) return;
        
        // Look for year pattern
        const yearMatch = part.match(/(\d{4}[a-z]?)/);
        if (!yearMatch) return;
        
        const year = yearMatch[1];
        // Extract everything before the year as authors
        const beforeYear = part.substring(0, part.indexOf(year)).replace(/[,\s]+$/, '').trim();
        
        if (beforeYear.length > 2) {
          const citationKey = normalize(beforeYear + ' ' + year);
          if (!foundCitations.has(citationKey)) {
            citations.push({
              original: `(${part})`,
              authors: beforeYear,
              year: year,
              normalized: citationKey,
              type: 'parenthetical'
            });
            foundCitations.add(citationKey);
          }
        }
      });
    }

    // Pattern 2: Narrative citations "Author (Year)" 
    const narrativePattern = /\b([A-Z][a-zA-Z\-\']+(?:\s+(?:and|&)\s+[A-Z][a-zA-Z\-\']+)*(?:\s+et\s+al\.?)?)\s+\((\d{4}[a-z]?)\)/g;
    
    while ((match = narrativePattern.exec(text)) !== null) {
      const authors = match[1];
      const year = match[2];
      const citationKey = normalize(authors + ' ' + year);
      
      if (!foundCitations.has(citationKey)) {
        citations.push({
          original: `${authors} (${year})`,
          authors: authors,
          year: year,
          normalized: citationKey,
          type: 'narrative'
        });
        foundCitations.add(citationKey);
      }
    }

    // Pattern 3: Complex multi-author patterns like "de Leersnyder, Kim, & Mesquita (2015)"
    const complexNarrativePattern = /\b([a-z]+\s+[A-Z][a-zA-Z\-\']+(?:\s*,\s*[A-Z][a-zA-Z\-\']+)*(?:\s*,?\s*&\s*[A-Z][a-zA-Z\-\']+)?)\s+\((\d{4}[a-z]?)\)/g;
    
    while ((match = complexNarrativePattern.exec(text)) !== null) {
      const authors = match[1];
      const year = match[2];
      const citationKey = normalize(authors + ' ' + year);
      
      if (!foundCitations.has(citationKey)) {
        citations.push({
          original: `${authors} (${year})`,
          authors: authors,
          year: year,
          normalized: citationKey,
          type: 'narrative-complex'
        });
        foundCitations.add(citationKey);
      }
    }

    console.log("Final citations list:");
    citations.forEach((cit, i) => {
      console.log(`  ${i}: "${cit.original}" -> Authors: "${cit.authors}" Year: "${cit.year}"`);
    });

    return citations;
  };

  const extractReferences = (text) => {
    const refSectionMatch = text.match(/(References|Bibliography|Works Cited)\s*\n([\s\S]*)/i);
    if (!refSectionMatch) return [];

    const refSection = refSectionMatch[2].trim();
    
    // NUCLEAR OPTION: Split by lines and rebuild completely
    const lines = refSection.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    const references = [];
    let currentRef = '';
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // MUCH MORE AGGRESSIVE: A line starts a new reference if:
      // 1. It starts with "Author, F." pattern
      // 2. OR it starts with a capital letter and contains a year in parentheses
      // 3. OR the previous line ended with a period and this starts with capital
      
      const isNewRefStart = 
        /^[A-Z][a-zA-Z\-\']+,\s+[A-Z]/.test(line) ||  // "Author, F."
        (/^[A-Z]/.test(line) && line.includes('(') && /\(\d{4}/.test(line)) || // Starts with capital and has year
        (currentRef.endsWith('.') && /^[A-Z]/.test(line) && line.length > 20); // Previous ended, this starts new
      
      if (isNewRefStart && currentRef.length > 30) {
        // Process the completed reference
        if (currentRef.includes('(') && /\(\d{4}/.test(currentRef)) {
          references.push(currentRef.trim());
        }
        currentRef = line;
      } else {
        // Continue building current reference
        currentRef += (currentRef.length > 0 ? ' ' : '') + line;
      }
    }
    
    // Don't forget the last reference
    if (currentRef.length > 30 && currentRef.includes('(') && /\(\d{4}/.test(currentRef)) {
      references.push(currentRef.trim());
    }
    
    console.log("Raw reference strings:", references);
    
    // Now process each reference to extract metadata
    const processedReferences = [];
    
    references.forEach((refText, index) => {
      // Find the year - look for (YYYY) pattern
      const yearMatches = refText.match(/\((\d{4}[a-z]?)\)/g);
      if (!yearMatches) {
        console.log(`Skipping reference ${index}: no year found in "${refText.substring(0, 100)}..."`);
        return;
      }
      
      // Take the first year found
      const yearMatch = yearMatches[0].match(/\((\d{4}[a-z]?)\)/);
      const year = yearMatch[1];
      
      // Extract authors - everything before the first occurrence of the year
      const yearIndex = refText.indexOf(`(${year})`);
      const beforeYear = refText.substring(0, yearIndex).trim();
      
      // Clean up the author string
      const cleanedAuthors = beforeYear.replace(/\.$/, '').trim();
      
      // Extract first author
      let firstAuthor = '';
      const firstCommaIndex = cleanedAuthors.indexOf(',');
      if (firstCommaIndex !== -1) {
        firstAuthor = cleanedAuthors.substring(0, firstCommaIndex).trim();
      } else {
        // Fallback: use first word
        firstAuthor = cleanedAuthors.split(/\s+/)[0] || '';
      }
      
      // Validate we got something reasonable
      if (!firstAuthor || firstAuthor.length < 2) {
        console.log(`Skipping reference ${index}: couldn't extract first author from "${cleanedAuthors}"`);
        return;
      }
      
      const processedRef = {
        original: refText,
        firstAuthor: firstAuthor,
        allAuthors: cleanedAuthors,
        year: year,
        normalized: normalize(cleanedAuthors + ' ' + year),
        firstAuthorNormalized: normalize(firstAuthor + ' ' + year)
      };
      
      console.log(`Reference ${index}: ${firstAuthor} (${year})`);
      processedReferences.push(processedRef);
    });
    
    console.log(`Successfully processed ${processedReferences.length} references out of ${references.length} raw references`);
    return processedReferences;
  };

  const matchCitationsToReferences = (citations, references) => {
    const fullMatches = [];
    const partialMatches = [];
    const unmatched = [];
    const usedReferences = new Set();

    // Debug: Let's see what we're working with
    console.log("Citations found:", citations.map(c => `${c.authors} (${c.year})`));
    console.log("References found:", references.map(r => `${r.firstAuthor} (${r.year})`));

    citations.forEach((citation) => {
      let bestMatch = null;
      let bestScore = 0;

      references.forEach((ref, refIndex) => {
        // MUCH MORE FLEXIBLE year matching
        const citationYear = citation.year.replace(/[a-z]$/, '');
        const refYear = ref.year.replace(/[a-z]$/, '');
        
        if (citationYear !== refYear) return;

        // Create multiple normalized versions for comparison
        const citationNorms = [
          normalize(citation.authors),
          normalize(extractFirstAuthor(citation.authors)),
          // Try just the surname
          normalize(extractFirstAuthor(citation.authors).split(' ').pop()),
        ];
        
        const refNorms = [
          normalize(ref.allAuthors),
          normalize(ref.firstAuthor),
          normalize(extractFirstAuthor(ref.firstAuthor)),
          // Try just the surname
          normalize(extractFirstAuthor(ref.firstAuthor).split(' ').pop()),
        ];

        let score = 0;
        let matchType = 'none';

        // Try all combinations
        for (let citNorm of citationNorms) {
          for (let refNorm of refNorms) {
            if (citNorm === refNorm && citNorm.length > 3) {
              score = 100;
              matchType = 'full';
              break;
            }
            // Partial match if one contains the other
            if (citNorm.length > 3 && refNorm.length > 3) {
              if (citNorm.includes(refNorm) || refNorm.includes(citNorm)) {
                score = Math.max(score, 85);
                matchType = 'partial';
              }
            }
          }
          if (score === 100) break;
        }

        // Special handling for "et al" cases
        if (citation.authors.toLowerCase().includes('et al')) {
          const citFirstOnly = normalize(extractFirstAuthor(citation.authors));
          const refFirstOnly = normalize(extractFirstAuthor(ref.firstAuthor));
          if (citFirstOnly === refFirstOnly && citFirstOnly.length > 3) {
            score = 95;
            matchType = 'full';
          }
        }

        // AGGRESSIVE: Look for surname matches in complex names
        const citationSurname = extractFirstAuthor(citation.authors).split(' ').pop().toLowerCase();
        const refSurname = extractFirstAuthor(ref.firstAuthor).split(' ').pop().toLowerCase();
        
        if (citationSurname === refSurname && citationSurname.length > 3) {
          score = Math.max(score, 80);
          if (matchType === 'none') matchType = 'partial';
        }

        if (score > bestScore) {
          bestScore = score;
          bestMatch = { reference: ref, index: refIndex, confidence: score, matchType };
        }
      });

      // LOWERED threshold to catch more matches
      if (bestMatch && bestMatch.confidence >= 75) {
        const matchData = {
          citation: citation,
          reference: bestMatch.reference,
          confidence: bestMatch.confidence,
          matchType: bestMatch.matchType
        };

        if (bestMatch.matchType === 'full' || bestMatch.confidence >= 90) {
          fullMatches.push(matchData);
        } else {
          partialMatches.push(matchData);
        }
        
        usedReferences.add(bestMatch.index);
      } else {
        unmatched.push({ citation: citation, suggestions: [] });
      }
    });

    const unusedReferences = references
      .filter((ref, index) => !usedReferences.has(index))
      .map(ref => ({ reference: ref, possibleMatches: [] }));

    return { fullMatches, partialMatches, unmatched, unusedReferences };
  };

  const performSecondAnalysis = (unusedRefs, documentText) => {
    const suggestions = [];
    const refSectionMatch = documentText.match(/(References|Bibliography|Works Cited)\s*\n/i);
    const mainDocument = refSectionMatch ? documentText.substring(0, refSectionMatch.index) : documentText;
    
    unusedRefs.forEach(unusedRef => {
      const ref = unusedRef.reference;
      const refFirstAuthor = extractFirstAuthor(ref.firstAuthor).toLowerCase();
      const refYear = ref.year;
      const candidates = [];
      
      const authorVariations = [
        refFirstAuthor,
        refFirstAuthor.charAt(0).toUpperCase() + refFirstAuthor.slice(1)
      ];
      
      // Handle compound surnames
      if (refFirstAuthor.includes(' ')) {
        const parts = refFirstAuthor.split(' ');
        if (parts.length > 1) {
          // Add full compound name
          authorVariations.push(parts.join(' '));
          // Add just surname
          const surname = parts[parts.length - 1];
          if (surname.length > 3) {
            authorVariations.push(surname);
            authorVariations.push(surname.charAt(0).toUpperCase() + surname.slice(1));
          }
        }
      }
      
      authorVariations.forEach(authorVar => {
        if (authorVar.length < 3) return;
        
        const escapedAuthor = authorVar.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        
        try {
          // IMPROVED: More flexible year matching
          const yearVariations = [refYear, refYear.replace(/[a-z]$/, '')];
          
          yearVariations.forEach(yearVar => {
            // Narrative citations
            const narrativeRegex = new RegExp(`\\b${escapedAuthor}[A-Za-z\\-]*(?:\\s+et\\s+al\\.?)?(?:'s)?\\s*\\(${yearVar}[a-z]?\\)`, 'gi');
            let match;
            while ((match = narrativeRegex.exec(mainDocument)) !== null) {
              candidates.push({ 
                text: match[0], 
                position: match.index, 
                confidence: 0.95, 
                type: 'narrative-citation' 
              });
            }
            
            // Parenthetical citations
            const parentheticalRegex = new RegExp(`\\([^)]*${escapedAuthor}[^)]*${yearVar}[a-z]?[^)]*\\)`, 'gi');
            while ((match = parentheticalRegex.exec(mainDocument)) !== null) {
              candidates.push({ 
                text: match[0], 
                position: match.index, 
                confidence: 0.9, 
                type: 'parenthetical-citation' 
              });
            }
          });
          
        } catch (e) {
          // Skip if regex fails
        }
      });
      
      const uniqueCandidates = candidates
        .filter((candidate, index, arr) => 
          arr.findIndex(c => c.text.trim() === candidate.text.trim()) === index
        )
        .filter(candidate => 
          candidate.text.length > 5 && 
          candidate.text.length < 200 &&
          !candidate.text.includes('doi.org') &&
          !candidate.text.includes('University') &&
          !candidate.text.includes('Journal of')
        )
        .sort((a, b) => b.confidence - a.confidence)
        .slice(0, 3);
      
      if (uniqueCandidates.length > 0) {
        suggestions.push({ reference: ref, candidates: uniqueCandidates });
      }
    });
    
    return suggestions;
  };

  const performThirdAnalysis = (missingCitations, documentText) => {
    const suggestions = [];
    
    missingCitations.forEach(missingCitation => {
      const citation = missingCitation.citation;
      const citationFirstAuthor = extractFirstAuthor(citation.authors).toLowerCase();
      const citationYear = citation.year;
      const candidates = [];
      
      const authorVariations = [
        citationFirstAuthor.substring(0, Math.max(3, citationFirstAuthor.length)),
        citationFirstAuthor.split(' ')[0],
        citation.authors.toLowerCase().substring(0, 6)
      ];
      
      authorVariations.forEach(authorVar => {
        if (authorVar.length < 2) return;
        
        const escapedAuthor = authorVar.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        
        try {
          // Look for year with suffix variations
          const yearVariations = [citationYear, citationYear.replace(/[a-z]$/, '')];
          
          yearVariations.forEach(yearVar => {
            const yearOnlyRegex = new RegExp(`\\(${yearVar}[a-z]?\\)`, 'gi');
            let match;
            while ((match = yearOnlyRegex.exec(documentText)) !== null) {
              const context = documentText.substring(Math.max(0, match.index - 100), match.index + 100);
              if (!context.toLowerCase().includes('reference') && !context.toLowerCase().includes('bibliography')) {
                candidates.push({ text: context, position: match.index, confidence: 0.7, type: 'year-match' });
              }
            }
          });
          
        } catch (e) {
          // Skip if regex fails
        }
      });
      
      const uniqueCandidates = candidates
        .filter((candidate, index, arr) => arr.findIndex(c => c.text === candidate.text) === index)
        .sort((a, b) => b.confidence - a.confidence)
        .slice(0, 5);
      
      if (uniqueCandidates.length > 0) {
        suggestions.push({ citation: citation, candidates: uniqueCandidates });
      }
    });
    
    return suggestions;
  };

  const runSecondAnalysis = () => {
    if (!results || !results.unused.length) return;
    setIsSecondAnalysisRunning(true);
    
    setTimeout(() => {
      const suggestions = performSecondAnalysis(results.unused, document);
      setSecondAnalysis(suggestions);
      setIsSecondAnalysisRunning(false);
    }, 1000);
  };

  const runThirdAnalysis = () => {
    if (!results || !results.missing.length) return;
    setIsThirdAnalysisRunning(true);
    
    setTimeout(() => {
      const suggestions = performThirdAnalysis(results.missing, document);
      setThirdAnalysis(suggestions);
      setIsThirdAnalysisRunning(false);
    }, 1000);
  };

  // FIXED: Proper summary recalculation
  const recalculateSummary = (newResults) => {
    return {
      totalCitations: newResults.fullMatches.length + newResults.partialMatches.length + newResults.missing.length,
      totalReferences: newResults.fullMatches.length + newResults.partialMatches.length + newResults.unused.length,
      fullMatches: newResults.fullMatches.length,
      partialMatches: newResults.partialMatches.length,
      missingReferences: newResults.missing.length,
      unusedReferences: newResults.unused.length
    };
  };

  const markAsMatch = (refIndex, candidateText) => {
    if (!secondAnalysis) return;
    
    const selectedSuggestion = secondAnalysis[refIndex];
    
    const updatedAnalysis = secondAnalysis.filter((suggestion, index) => index !== refIndex);
    setSecondAnalysis(updatedAnalysis);
    
    setResults(prev => {
      const newUnused = prev.unused.filter(u => u.reference.original !== selectedSuggestion.reference.original);
      
      const newMatch = {
        citation: {
          original: candidateText,
          authors: extractFirstAuthor(selectedSuggestion.reference.firstAuthor),
          year: selectedSuggestion.reference.year,
          type: 'confirmed'
        },
        reference: selectedSuggestion.reference,
        confidence: 'User Confirmed',
        matchType: 'user_confirmed'
      };
      
      const newResults = {
        ...prev,
        partialMatches: [...prev.partialMatches, newMatch],
        unused: newUnused
      };
      
      // FIXED: Proper summary recalculation
      newResults.summary = recalculateSummary(newResults);
      
      return newResults;
    });
  };

  const markAsNonMatch = (refIndex) => {
    if (!secondAnalysis) return;
    const updatedAnalysis = secondAnalysis.filter((suggestion, index) => index !== refIndex);
    setSecondAnalysis(updatedAnalysis);
  };

  const markThirdAsMatch = (citationIndex, candidateText) => {
    if (!thirdAnalysis) return;
    
    const selectedSuggestion = thirdAnalysis[citationIndex];
    
    const updatedAnalysis = thirdAnalysis.filter((suggestion, index) => index !== citationIndex);
    setThirdAnalysis(updatedAnalysis);
    
    setResults(prev => {
      const newMissing = prev.missing.filter(m => m.citation.original !== selectedSuggestion.citation.original);
      
      const newMatch = {
        citation: selectedSuggestion.citation,
        reference: {
          original: candidateText,
          firstAuthor: selectedSuggestion.citation.authors,
          allAuthors: selectedSuggestion.citation.authors,
          year: selectedSuggestion.citation.year
        },
        confidence: 'User Confirmed',
        matchType: 'user_confirmed_missing'
      };
      
      const newResults = {
        ...prev,
        fullMatches: [...prev.fullMatches, newMatch],
        missing: newMissing
      };
      
      // FIXED: Proper summary recalculation
      newResults.summary = recalculateSummary(newResults);
      
      return newResults;
    });
  };

  const markThirdAsNonMatch = (citationIndex) => {
    if (!thirdAnalysis) return;
    const updatedAnalysis = thirdAnalysis.filter((suggestion, index) => index !== citationIndex);
    setThirdAnalysis(updatedAnalysis);
  };

  const parseReference = (reference) => {
    const ref = reference.original;
    const yearMatch = ref.match(/\((\d{4}[a-z]?)\)/);
    const year = yearMatch ? yearMatch[1] : null;
    
    let title = '';
    if (yearMatch) {
      const afterYear = ref.substring(ref.indexOf(yearMatch[0]) + yearMatch[0].length).trim();
      const titleMatch = afterYear.match(/^\.?\s*([^.]+)\./);
      if (titleMatch) {
        title = titleMatch[1].trim();
      }
    }
    
    let authors = '';
    if (yearMatch) {
      authors = ref.substring(0, ref.indexOf(yearMatch[0])).trim();
      authors = authors.replace(/\.$/, '');
    }
    
    const firstAuthor = extractFirstAuthor(authors);
    
    return { title, authors, firstAuthor, year };
  };

  const verifyReferences = async () => {
    if (!results) return;
    setIsVerifying(true);
    
    const allReferences = [...results.fullMatches.map(m => m.reference), ...results.partialMatches.map(m => m.reference), ...results.unused.map(u => u.reference)];
    const verificationResults = {};
    
    for (const ref of allReferences) {
      try {
        const { title, firstAuthor, year } = parseReference(ref);
        const searchQuery = `${title} ${firstAuthor} ${year || ''}`.trim();
        const googleScholarUrl = `https://scholar.google.com/scholar?q=${encodeURIComponent(searchQuery)}`;
        
        verificationResults[ref.original] = { 
          status: 'Search on Google Scholar', 
          details: 'Click link to search for this reference on Google Scholar',
          googleScholarUrl: googleScholarUrl
        };
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        verificationResults[ref.original] = { 
          status: 'Error', 
          details: 'Could not create search link' 
        };
      }
    }
    
    setVerificationResults(verificationResults);
    setIsVerifying(false);
  };

  const generateTextReport = () => {
    if (!results) return '';
    
    let report = 'ACADEMIC REFERENCE CHECK REPORT\n';
    report += '=' + '='.repeat(50) + '\n\n';
    
    report += 'SUMMARY\n';
    report += '-'.repeat(20) + '\n';
    report += `Total Citations: ${results.summary.totalCitations}\n`;
    report += `Full Matches: ${results.summary.fullMatches}\n`;
    report += `Partial Matches: ${results.summary.partialMatches}\n`;
    report += `Missing References: ${results.summary.missingReferences}\n`;
    report += `Unused References: ${results.summary.unusedReferences}\n\n`;

    if (results.fullMatches.length > 0) {
      report += `FULL MATCHES (${results.fullMatches.length})\n`;
      report += '-'.repeat(30) + '\n';
      results.fullMatches.forEach((item, index) => {
        report += `${index + 1}. Citation: ${item.citation.original}\n`;
        report += `   Matches: ${item.reference.original}\n`;
        if (verificationResults && verificationResults[item.reference.original]) {
          report += `   Verification: ${verificationResults[item.reference.original].status}\n`;
        }
        report += '\n';
      });
    }

    if (results.partialMatches.length > 0) {
      report += `PARTIAL MATCHES (${results.partialMatches.length})\n`;
      report += '-'.repeat(30) + '\n';
      results.partialMatches.forEach((item, index) => {
        report += `${index + 1}. Citation: ${item.citation.original}\n`;
        report += `   Matches: ${item.reference.original}\n`;
        const confidenceText = item.confidence === 'User Confirmed' ? 'User Confirmed' : `${item.confidence}% confidence`;
        report += `   Confidence: ${confidenceText}\n`;
        report += '\n';
      });
    }

    if (results.missing.length > 0) {
      report += `MISSING REFERENCES (${results.missing.length})\n`;
      report += '-'.repeat(30) + '\n';
      results.missing.forEach((item, index) => {
        report += `${index + 1}. Citation: ${item.citation.original}\n`;
        report += `   Authors: ${item.citation.authors} | Year: ${item.citation.year}\n\n`;
      });
    }

    if (results.unused.length > 0) {
      report += `UNUSED REFERENCES (${results.unused.length})\n`;
      report += '-'.repeat(30) + '\n';
      results.unused.forEach((item, index) => {
        report += `${index + 1}. Reference: ${item.reference.original}\n\n`;
      });
    }

    report += `Report generated on ${new Date().toLocaleString()}\n`;
    
    return report;
  };

  const processDocument = () => {
    if (!document.trim()) return;
    
    setIsProcessing(true);
    setSecondAnalysis(null);
    setThirdAnalysis(null);
    setVerificationResults(null);
    
    setTimeout(() => {
      console.log("=== STARTING ANALYSIS ===");
      const citations = extractCitations(document);
      console.log(`Found ${citations.length} citations:`, citations.map(c => c.original));
      
      const references = extractReferences(document);
      console.log(`Found ${references.length} references:`, references.map(r => r.firstAuthor + ' (' + r.year + ')'));
      
      const matchResults = matchCitationsToReferences(citations, references);
      console.log("Match results:", {
        fullMatches: matchResults.fullMatches.length,
        partialMatches: matchResults.partialMatches.length,
        unmatched: matchResults.unmatched.length,
        unused: matchResults.unusedReferences.length
      });
      
      const newResults = {
        fullMatches: matchResults.fullMatches,
        partialMatches: matchResults.partialMatches,
        missing: matchResults.unmatched,
        unused: matchResults.unusedReferences
      };
      
      newResults.summary = recalculateSummary(newResults);

      setResults(newResults);
      setIsProcessing(false);
    }, 1500);
  };

  const getConfidenceBadge = (confidence) => {
    if (confidence === 'User Confirmed') return 'bg-blue-100 text-blue-800';
    if (confidence >= 90) return 'bg-green-100 text-green-800';
    if (confidence >= 70) return 'bg-yellow-100 text-yellow-800';
    return 'bg-red-100 text-red-800';
  };

  const getConfidenceColor = (confidence) => {
    if (confidence >= 0.8) return 'text-green-600';
    if (confidence >= 0.6) return 'text-yellow-600';
    return 'text-red-600';
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
      <div className="max-w-6xl mx-auto">
        <div className="text-center mb-8">
          <div className="flex items-center justify-center mb-4">
            <i data-lucide="file-text" className="h-12 w-12 text-indigo-600 mr-3"></i>
            <h1 className="text-4xl font-bold text-gray-800">Improved Academic Reference Checker</h1>
          </div>
          <p className="text-lg text-gray-600">
            Enhanced citation matching with better handling of complex author names and year suffixes
          </p>
        </div>

        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
          <div className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Document Text
            </label>
            <textarea
              value={document}
              onChange={(e) => setDocument(e.target.value)}
              placeholder="Paste your academic document here... Now with improved handling of complex citations like (de Leersnyder, Kim, & Mesquita, 2015)"
              className="w-full h-64 p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none"
            />
          </div>

          <button
            onClick={processDocument}
            disabled={!document.trim() || isProcessing}
            className="w-full bg-indigo-600 text-white py-3 px-6 rounded-lg hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors flex items-center justify-center space-x-2"
          >
            {isProcessing ? (
              <>
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                <span>Processing Document...</span>
              </>
            ) : (
              <>
                <i data-lucide="search" className="h-5 w-5"></i>
                <span>Analyze References</span>
              </>
            )}
          </button>
        </div>

        {results && (
          <div className="space-y-6">
            <div className="bg-white rounded-xl shadow-lg p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-2xl font-bold text-gray-800">Analysis Summary</h2>
                <div className="flex space-x-2">
                  {results.unused.length > 0 && !secondAnalysis && (
                    <button
                      onClick={runSecondAnalysis}
                      disabled={isSecondAnalysisRunning}
                      className="flex items-center space-x-2 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 disabled:bg-gray-400 transition-colors"
                    >
                      {isSecondAnalysisRunning ? (
                        <>
                          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                          <span>Analyzing...</span>
                        </>
                      ) : (
                        <>
                          <i data-lucide="refresh-cw" className="h-4 w-4"></i>
                          <span>Find More Matches</span>
                        </>
                      )}
                    </button>
                  )}
                  {results.missing.length > 0 && !thirdAnalysis && (
                    <button
                      onClick={runThirdAnalysis}
                      disabled={isThirdAnalysisRunning}
                      className="flex items-center space-x-2 bg-orange-600 text-white px-4 py-2 rounded-lg hover:bg-orange-700 disabled:bg-gray-400 transition-colors"
                    >
                      {isThirdAnalysisRunning ? (
                        <>
                          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                          <span>Analyzing...</span>
                        </>
                      ) : (
                        <>
                          <i data-lucide="refresh-cw" className="h-4 w-4"></i>
                          <span>Search Missing ({results.missing.length})</span>
                        </>
                      )}
                    </button>
                  )}
                  <button
                    onClick={verifyReferences}
                    disabled={isVerifying}
                    className="flex items-center space-x-2 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 disabled:bg-gray-400 transition-colors"
                  >
                    {isVerifying ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                        <span>Creating Links...</span>
                      </>
                    ) : (
                      <>
                        <i data-lucide="check-circle" className="h-4 w-4"></i>
                        <span>Google Scholar Links</span>
                      </>
                    )}
                  </button>
                  <button
                    onClick={(e) => {
                      try {
                        const reportText = generateTextReport();
                        navigator.clipboard.writeText(reportText);
                        // Visual feedback
                        const btn = e.target.closest('button');
                        const originalText = btn.innerHTML;
                        btn.textContent = 'Copied!';
                        setTimeout(() => {
                          btn.innerHTML = originalText;
                          lucide.createIcons();
                        }, 2000);
                      } catch (err) {
                        alert('Failed to copy to clipboard. Please try selecting and copying the text manually.');
                        console.error('Clipboard error:', err);
                      }
                    }}
                    className="flex items-center space-x-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors"
                  >
                    <i data-lucide="file-text" className="h-4 w-4"></i>
                    <span>Copy Report</span>
                  </button>
                </div>
              </div>
              
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
                <div className="bg-blue-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-blue-600">{results.summary.totalCitations}</div>
                  <div className="text-sm text-gray-600">Citations Found</div>
                </div>
                <div className="bg-emerald-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-emerald-600">{results.summary.fullMatches}</div>
                  <div className="text-sm text-gray-600">Full Matches</div>
                </div>
                <div className="bg-green-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-green-600">{results.summary.partialMatches}</div>
                  <div className="text-sm text-gray-600">Partial Matches</div>
                </div>
                <div className="bg-red-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-red-600">{results.summary.missingReferences}</div>
                  <div className="text-sm text-gray-600">Missing Refs</div>
                </div>
                <div className="bg-orange-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-orange-600">{results.summary.unusedReferences}</div>
                  <div className="text-sm text-gray-600">Unused Refs</div>
                </div>
              </div>
            </div>

            {secondAnalysis && secondAnalysis.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center">
                    <i data-lucide="refresh-cw" className="h-6 w-6 text-purple-500 mr-2"></i>
                    <h3 className="text-xl font-bold text-gray-800">Potential Matches Found ({secondAnalysis.length})</h3>
                  </div>
                </div>
                <div className="space-y-4">
                  {secondAnalysis.map((suggestion, index) => (
                    <div key={index} className="border rounded-lg p-4 bg-purple-50 border-purple-200">
                      <div className="font-semibold text-gray-800 mb-2">
                        Reference: {suggestion.reference.original.substring(0, 100)}...
                      </div>
                      <div>
                        <div className="text-sm font-medium text-gray-700 mb-2 flex items-center justify-between">
                          <span>Potential citations found:</span>
                          <button
                            onClick={() => markAsNonMatch(index)}
                            className="px-2 py-1 bg-red-500 text-white text-xs rounded hover:bg-red-600 transition-colors"
                          >
                            Mark as Non-Match
                          </button>
                        </div>
                        {suggestion.candidates.map((candidate, candIndex) => (
                          <div key={candIndex} className="mb-2 p-2 bg-white border rounded">
                            <div className="flex items-center justify-between">
                              <div className="flex-1">
                                <div className="text-sm font-mono bg-gray-100 p-2 rounded">
                                  {candidate.text}
                                </div>
                                <div className={`text-xs mt-1 ${getConfidenceColor(candidate.confidence)}`}>
                                  {Math.round(candidate.confidence * 100)}% confidence • {candidate.type}
                                </div>
                              </div>
                              <div className="ml-4 flex space-x-2">
                                <button
                                  onClick={() => markAsMatch(index, candidate.text)}
                                  className="px-3 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600 transition-colors"
                                >
                                  Mark as Match
                                </button>
                                <a
                                  href={`https://www.google.com/search?q=${encodeURIComponent(suggestion.reference.original)}`}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="px-3 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600 transition-colors"
                                >
                                  Google
                                </a>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {thirdAnalysis && thirdAnalysis.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center">
                    <i data-lucide="refresh-cw" className="h-6 w-6 text-orange-500 mr-2"></i>
                    <h3 className="text-xl font-bold text-gray-800">Missing Citations Search Results ({thirdAnalysis.length})</h3>
                  </div>
                </div>
                <div className="space-y-4">
                  {thirdAnalysis.map((suggestion, index) => (
                    <div key={index} className="border rounded-lg p-4 bg-orange-50 border-orange-200">
                      <div className="font-semibold text-gray-800 mb-2">
                        Missing Citation: {suggestion.citation.original}
                      </div>
                      <div>
                        <div className="text-sm font-medium text-gray-700 mb-2 flex items-center justify-between">
                          <span>Potential references found:</span>
                          <button
                            onClick={() => markThirdAsNonMatch(index)}
                            className="px-2 py-1 bg-red-500 text-white text-xs rounded hover:bg-red-600 transition-colors"
                          >
                            Mark as Non-Match
                          </button>
                        </div>
                        {suggestion.candidates.map((candidate, candIndex) => (
                          <div key={candIndex} className="mb-2 p-2 bg-white border rounded">
                            <div className="flex items-center justify-between">
                              <div className="flex-1">
                                <div className="text-sm font-mono bg-gray-100 p-2 rounded">
                                  {candidate.text}
                                </div>
                                <div className={`text-xs mt-1 ${getConfidenceColor(candidate.confidence)}`}>
                                  {Math.round(candidate.confidence * 100)}% confidence • {candidate.type}
                                </div>
                              </div>
                              <div className="ml-4 flex space-x-2">
                                <button
                                  onClick={() => markThirdAsMatch(index, candidate.text)}
                                  className="px-3 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600 transition-colors"
                                >
                                  Mark as Match
                                </button>
                                <a
                                  href={`https://www.google.com/search?q=${encodeURIComponent(suggestion.citation.original)}`}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="px-3 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600 transition-colors"
                                >
                                  Google
                                </a>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.missing.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <i data-lucide="alert-circle" className="h-6 w-6 text-red-500 mr-2"></i>
                  <h3 className="text-xl font-bold text-gray-800">Missing References ({results.missing.length})</h3>
                </div>
                <div className="space-y-4">
                  {results.missing.map((item, index) => (
                    <div key={index} className="border border-red-200 rounded-lg p-4 bg-red-50">
                      <div className="font-semibold text-red-800 mb-2">
                        Citation: {item.citation.original}
                      </div>
                      <div className="text-sm text-gray-600 mb-2">
                        Authors: {item.citation.authors} | Year: {item.citation.year}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.fullMatches.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <i data-lucide="check-circle" className="h-6 w-6 text-emerald-500 mr-2"></i>
                  <h3 className="text-xl font-bold text-gray-800">Full Matches ({results.fullMatches.length})</h3>
                </div>
                <div className="space-y-3">
                  {results.fullMatches.map((item, index) => (
                    <div key={index} className="border border-emerald-200 rounded-lg p-4 bg-emerald-50">
                      <div className="flex items-center justify-between">
                        <div className="flex-1">
                          <div className="font-semibold text-emerald-800">
                            Citation: {item.citation.original}
                          </div>
                          <div className="text-sm text-gray-600 mt-1">
                            Matches: {item.reference.original}
                          </div>
                          {verificationResults && verificationResults[item.reference.original] && (
                            <div className="mt-2 text-xs bg-blue-50 p-2 rounded">
                              <strong>Google Scholar:</strong> {verificationResults[item.reference.original].status}
                              {verificationResults[item.reference.original].googleScholarUrl && (
                                <div className="mt-1">
                                  <a 
                                    href={verificationResults[item.reference.original].googleScholarUrl} 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="text-blue-600 hover:text-blue-800 underline"
                                  >
                                    Search on Google Scholar
                                  </a>
                                </div>
                              )}
                            </div>
                          )}
                        </div>
                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${getConfidenceBadge(item.confidence)}`}>
                          {item.confidence === 'User Confirmed' ? 'User Confirmed' : `${item.confidence}% confidence`}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.partialMatches.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <i data-lucide="check-circle" className="h-6 w-6 text-green-500 mr-2"></i>
                  <h3 className="text-xl font-bold text-gray-800">Partial Matches ({results.partialMatches.length})</h3>
                </div>
                <div className="space-y-3">
                  {results.partialMatches.map((item, index) => (
                    <div key={index} className="border border-green-200 rounded-lg p-4 bg-green-50">
                      <div className="flex items-center justify-between">
                        <div className="flex-1">
                          <div className="font-semibold text-green-800">
                            Citation: {item.citation.original}
                          </div>
                          <div className="text-sm text-gray-600 mt-1">
                            Matches: {item.reference.original}
                          </div>
                          {verificationResults && verificationResults[item.reference.original] && (
                            <div className="mt-2 text-xs bg-blue-50 p-2 rounded">
                              <strong>Google Scholar:</strong> {verificationResults[item.reference.original].status}
                              {verificationResults[item.reference.original].googleScholarUrl && (
                                <div className="mt-1">
                                  <a 
                                    href={verificationResults[item.reference.original].googleScholarUrl} 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="text-blue-600 hover:text-blue-800 underline"
                                  >
                                    Search on Google Scholar
                                  </a>
                                </div>
                              )}
                            </div>
                          )}
                        </div>
                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${getConfidenceBadge(item.confidence)}`}>
                          {item.confidence === 'User Confirmed' ? 'User Confirmed' : `${item.confidence}% confidence`}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.unused.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <i data-lucide="alert-circle" className="h-6 w-6 text-orange-500 mr-2"></i>
                  <h3 className="text-xl font-bold text-gray-800">Unused References ({results.unused.length})</h3>
                </div>
                <div className="space-y-4">
                  {results.unused.map((item, index) => (
                    <div key={index} className="border border-orange-200 rounded-lg p-4 bg-orange-50">
                      <div className="font-semibold text-orange-800 mb-2">
                        {item.reference.original}
                      </div>
                      {verificationResults && verificationResults[item.reference.original] && (
                        <div className="text-xs bg-blue-50 p-2 rounded">
                          <strong>Google Scholar:</strong> {verificationResults[item.reference.original].status}
                          {verificationResults[item.reference.original].googleScholarUrl && (
                            <div className="mt-1">
                              <a 
                                href={verificationResults[item.reference.original].googleScholarUrl} 
                                target="_blank" 
                                rel="noopener noreferrer"
                                className="text-blue-600 hover:text-blue-800 underline"
                              >
                                Search on Google Scholar
                              </a>
                            </div>
                          )}
                        </div>
                      )}
                      <div className="mt-2">
                        <a
                          href={`https://www.google.com/search?q=${encodeURIComponent(item.reference.original)}`}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-xs text-blue-600 hover:text-blue-800 underline"
                        >
                          Google Search for Reference
                        </a>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

ReactDOM.render(<ReferenceChecker />, document.getElementById('root'));
    </script>
</body>
</html>
