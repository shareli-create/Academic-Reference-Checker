<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Academic Reference Checker</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.10.0/mammoth.browser.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
const { useState } = React;

const ReferenceChecker = () => {
  const [documentText, setDocumentText] = useState('');
  const [results, setResults] = useState(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [lenientMatches, setLenientMatches] = useState(null);
  const [isLenientAnalysisRunning, setIsLenientAnalysisRunning] = useState(false);

  const handleFileSelect = (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const arrayBuffer = e.target.result;
            mammoth.extractRawText({ arrayBuffer: arrayBuffer })
                .then(result => {
                    const newText = result.value;
                    setDocumentText(newText);
                    processDocument(newText);
                })
                .catch(err => {
                    console.error("Error reading docx file:", err);
                    alert(`Error reading .docx file: ${err.message}`);
                });
        };
        reader.readAsArrayBuffer(file);
    }
  };

  const normalize = (text) => text.toLowerCase().replace(/[.,&]/g, '').replace(/\s+et\s+al\.?/g, '').replace(/[-\s]+/g, ' ').replace(/\s+/g, ' ').trim();
  const extractFirstAuthor = (authorString) => authorString.split(/\s*[&,]\s*/)[0].replace(/\s+et\s+al\.?/i, '').trim();

  const extractCitations = (text) => {
    const citations = [];
    const foundCitations = new Set();
    
    const pattern = /\([^)]*[A-Z][A-Za-z\-\']*(?:\s*-\s*[A-Za-z\-\']+)*(?:\s+et\s+al\.?)?.*?\d{4}[^)]*\)/g;
    const matches = text.match(pattern) || [];
    
    matches.forEach(match => {
      const cleaned = match.replace(/[()]/g, '');
      const groups = cleaned.split(';');
      
      groups.forEach(group => {
        group = group.trim();
        const authorYearMatch = group.match(/^([A-Za-z\-\'\s,&]+?)\s*,?\s*(\d{4})/);
        
        if (authorYearMatch) {
          let authors = authorYearMatch[1].trim()
            .replace(/^(e\.g\.,|see|cf\.)\s*/i, '')
            .replace(/,?\s*p\.\s*\d+.*$/, '')
            .replace(/\s*,\s*$/, '').trim();
          const year = authorYearMatch[2];
          const citationKey = normalize(authors + ' ' + year);
          
          if (!foundCitations.has(citationKey)) {
            citations.push({
              original: `(${group.trim()})`,
              authors: authors,
              year: year,
              normalized: citationKey,
              type: 'parenthetical'
            });
            foundCitations.add(citationKey);
          }
        }
      });
    });

    const narrativePattern = /\b([A-Z][A-Za-z\-\']*(?:\s*-\s*[A-Za-z\-\']+)*(?:\s+et\s+al\.?)?(?:'s)?)\s+\((\d{4})\)/g;
    let narrativeMatch;
    while ((narrativeMatch = narrativePattern.exec(text)) !== null) {
      const leadAuthor = narrativeMatch[1].replace(/'s$/, '');
      const year = narrativeMatch[2];
      const citationKey = normalize(leadAuthor + ' ' + year);
      
      if (!foundCitations.has(citationKey)) {
        citations.push({
          original: `${leadAuthor} (${year})`,
          authors: leadAuthor,
          year: year,
          normalized: citationKey,
          type: 'narrative'
        });
        foundCitations.add(citationKey);
      }
    }

    return citations;
  };

  const extractReferences = (text) => {
    const headingOptions = ["References", "Bibliography", "Works Cited"];
    let refStartIndex = -1;
    let headingFound = '';

    for (const heading of headingOptions) {
        const regex = new RegExp(`^\\s*${heading}\\s*$`, "im");
        const match = text.match(regex);
        if (match) {
            refStartIndex = match.index;
            headingFound = match[0];
            break;
        }
    }

    if (refStartIndex === -1) {
        return [];
    }

    const refContent = text.substring(refStartIndex + headingFound.length);
    
    const refLines = refContent.split('\n').filter(line => {
        return line.trim().length > 20 && /\(\d{4}\)/.test(line);
    });

    const references = [];
    refLines.forEach(line => {
      const yearMatch = line.match(/\((\d{4})\)/);
      if (!yearMatch) return;
      
      const year = yearMatch[1];
      const beforeYear = line.substring(0, line.indexOf(`(${year})`)).trim();
      const firstCommaIndex = beforeYear.indexOf(',');
      const firstAuthor = firstCommaIndex !== -1 ? beforeYear.substring(0, firstCommaIndex).trim() : beforeYear;
      const allAuthors = beforeYear.replace(/\([^)]*\)/g, '').replace(/\.$/, '').trim();
      
      references.push({
        original: line.trim(),
        firstAuthor: firstAuthor,
        allAuthors: allAuthors,
        year: year,
        normalized: normalize(allAuthors + ' ' + year),
        firstAuthorNormalized: normalize(firstAuthor + ' ' + year)
      });
    });

    return references;
  };

  const matchCitationsToReferences = (citations, references) => {
    const fullMatches = [];
    const partialMatches = [];
    const unmatched = [];
    const usedReferences = new Set();

    citations.forEach((citation) => {
      let bestMatch = null;
      let bestScore = 0;

      references.forEach((ref, refIndex) => {
        if (citation.year !== ref.year) return;

        const citationAuthorsNorm = normalize(citation.authors);
        const refAllAuthorsNorm = normalize(ref.allAuthors);
        const citationFirstAuthor = normalize(extractFirstAuthor(citation.authors));
        const refFirstAuthor = normalize(extractFirstAuthor(ref.firstAuthor));

        let score = 0;
        let matchType = 'none';

        if (citation.normalized === ref.normalized || citation.normalized === ref.firstAuthorNormalized) {
          score = 100;
          matchType = 'full';
        } else if (citationAuthorsNorm === refAllAuthorsNorm) {
          score = 100;
          matchType = 'full';
        } else if (citationFirstAuthor === refFirstAuthor && citationFirstAuthor.length > 2) {
          score = 90;
          matchType = 'partial';
        }

        if (score > bestScore) {
          bestScore = score;
          bestMatch = { reference: ref, index: refIndex, confidence: score, matchType };
        }
      });

      if (bestMatch && bestMatch.confidence >= 85) {
        const matchData = {
          citation: citation,
          reference: bestMatch.reference,
          confidence: bestMatch.confidence,
          matchType: bestMatch.matchType
        };

        if (bestMatch.matchType === 'full') {
          fullMatches.push(matchData);
        } else {
          partialMatches.push(matchData);
        }
        
        usedReferences.add(bestMatch.index);
      } else {
        unmatched.push({ citation: citation, suggestions: [] });
      }
    });

    const unusedReferences = references
      .filter((ref, index) => !usedReferences.has(index))
      .map(ref => ({ reference: ref, possibleMatches: [] }));

    return { fullMatches, partialMatches, unmatched, unusedReferences };
  };

  const performLenientAnalysis = (unusedRefs, missingCitations) => {
    const suggestions = [];

    unusedRefs.forEach(unused => {
      const unusedRef = unused.reference;
      const potentialMatches = [];

      missingCitations.forEach(missing => {
        const missingCit = missing.citation;

        const refFirstAuthorNorm = normalize(extractFirstAuthor(unusedRef.firstAuthor));
        const citFirstAuthorNorm = normalize(extractFirstAuthor(missingCit.authors));

        if (unusedRef.year === missingCit.year && refFirstAuthorNorm === citFirstAuthorNorm && refFirstAuthorNorm.length > 2) {
          potentialMatches.push({
            citation: missingCit,
            confidence: 90, // Same as partial match confidence
            matchType: 'lenient-suggestion'
          });
        }
      });

      if (potentialMatches.length > 0) {
        suggestions.push({
          reference: unusedRef,
          candidates: potentialMatches
        });
      }
    });
    
    return suggestions;
  };

  const runLenientAnalysis = () => {
    if (!results || !results.unused.length || !results.missing.length) return;
    setIsLenientAnalysisRunning(true);
    
    setTimeout(() => {
      const suggestions = performLenientAnalysis(results.unused, results.missing);
      setLenientMatches(suggestions);
      setIsLenientAnalysisRunning(false);
    }, 1000);
  };

  const confirmLenientMatch = (suggestionToConfirm, confirmedCitation) => {
    if (!results || !suggestionToConfirm) return;

    // Create a new match object using the confirmed pair
    const newMatch = {
      citation: confirmedCitation,
      reference: suggestionToConfirm.reference,
      confidence: 'User Confirmed',
      matchType: 'user_confirmed'
    };

    // Add the new match to the partialMatches list
    const newPartialMatches = [...results.partialMatches, newMatch];

    // Remove the used reference from the unused list
    const updatedUnused = results.unused.filter(u => u.reference.original !== suggestionToConfirm.reference.original);
    
    // Remove the matched citation from the missing list
    const updatedMissing = results.missing.filter(m => m.citation.original !== confirmedCitation.original);

    // Update the summary counts
    const newSummary = {
      ...results.summary,
      partialMatches: newPartialMatches.length,
      unusedReferences: updatedUnused.length,
      missingReferences: updatedMissing.length,
    };

    // Update the main results state
    setResults({
      ...results,
      partialMatches: newPartialMatches,
      unused: updatedUnused,
      missing: updatedMissing,
      summary: newSummary,
    });

    // Remove the entire suggestion group from the lenient matches display
    setLenientMatches(prev => prev.filter(s => s.reference.original !== suggestionToConfirm.reference.original));
  };

  const dismissLenientSuggestion = (suggestionToDismiss, candidateToDismiss) => {
    setLenientMatches(prev => {
        const newAnalysis = prev.map(suggestion => {
            if (suggestion.reference.original === suggestionToDismiss.reference.original) {
                const newCandidates = suggestion.candidates.filter(c => c.citation.original !== candidateToDismiss.citation.original);
                return { ...suggestion, candidates: newCandidates };
            }
            return suggestion;
        });
        // Remove the suggestion if it has no more candidates
        return newAnalysis.filter(suggestion => suggestion.candidates.length > 0);
    });
  };
  
  const processDocument = (textToProcess) => {
    const docText = textToProcess || documentText;
    if (!docText.trim()) return;
    
    setResults(null);
    setLenientMatches(null);
    setIsProcessing(true);
    
    setTimeout(() => {
      const citations = extractCitations(docText);
      const references = extractReferences(docText);
      const matchResults = matchCitationsToReferences(citations, references);
      
      const summary = {
        totalCitations: citations.length,
        totalReferences: references.length,
        fullMatches: matchResults.fullMatches.length,
        partialMatches: matchResults.partialMatches.length,
        missingReferences: matchResults.unmatched.length,
        unusedReferences: matchResults.unusedReferences.length,
      };

      setResults({
        summary,
        fullMatches: matchResults.fullMatches,
        partialMatches: matchResults.partialMatches,
        missing: matchResults.unmatched,
        unused: matchResults.unusedReferences
      });
      
      setIsProcessing(false);
    }, 1500);
  };

  const generateHtmlReport = () => {
    if (!results) return '';

    const styles = `
      body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; color: #333; }
      h1, h2, h3 { color: #2c3e50; }
      h1 { font-size: 2em; }
      h2 { font-size: 1.5em; border-bottom: 2px solid #ccc; padding-bottom: 5px; margin-top: 30px;}
      .summary-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-bottom: 30px; }
      .summary-card { background: #f9f9f9; border: 1px solid #eee; border-left: 5px solid #3498db; padding: 15px; border-radius: 5px; }
      .summary-card .value { font-size: 1.8em; font-weight: bold; }
      .result-item { background: #fdfdfd; border: 1px solid #eee; padding: 15px; margin-bottom: 15px; border-radius: 5px; }
      .result-item .citation { font-weight: bold; }
      .result-item .reference { margin-top: 5px; padding-left: 15px; border-left: 3px solid #ddd; }
      .full-match { border-left-color: #2ecc71; }
      .partial-match { border-left-color: #f1c40f; }
      .missing-ref { border-left-color: #e74c3c; color: #e74c3c; }
      .unused-ref { border-left-color: #e67e22; }
    `;

    let html = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <title>Academic Reference Check Report</title>
        <style>${styles}</style>
      </head>
      <body>
        <h1>Academic Reference Check Report</h1>
        <p>Report generated on ${new Date().toLocaleString()}</p>
        
        <h2>Summary</h2>
        <div class="summary-grid">
          <div class="summary-card"><div class="value">${results.summary.totalCitations}</div><div>Total Citations</div></div>
          <div class="summary-card"><div class="value">${results.summary.fullMatches}</div><div>Full Matches</div></div>
          <div class="summary-card"><div class="value">${results.summary.partialMatches}</div><div>Partial Matches</div></div>
          <div class="summary-card"><div class="value">${results.summary.missingReferences}</div><div>Missing Refs</div></div>
          <div class="summary-card"><div class="value">${results.summary.unusedReferences}</div><div>Unused Refs</div></div>
        </div>
    `;

    if (results.fullMatches.length > 0) {
      html += '<h2>Full Matches</h2>';
      results.fullMatches.forEach(item => {
        html += `
          <div class="result-item full-match">
            <div class="citation">Citation: ${item.citation.original}</div>
            <div class="reference">Matches: ${item.reference.original}</div>
          </div>
        `;
      });
    }
    
    if (results.partialMatches.length > 0) {
      html += '<h2>Partial Matches</h2>';
      results.partialMatches.forEach(item => {
        html += `
          <div class="result-item partial-match">
            <div class="citation">Citation: ${item.citation.original}</div>
            <div class="reference">Matches: ${item.reference.original}</div>
          </div>
        `;
      });
    }

    if (results.missing.length > 0) {
      html += '<h2>Missing References</h2>';
      results.missing.forEach(item => {
        html += `<div class="result-item missing-ref"><div class="citation">Citation: ${item.citation.original}</div></div>`;
      });
    }

    if (results.unused.length > 0) {
      html += '<h2>Unused References</h2>';
      results.unused.forEach(item => {
        html += `<div class="result-item unused-ref"><div class="reference">${item.reference.original}</div></div>`;
      });
    }

    html += '</body></html>';
    return html;
  };

  const downloadHtmlReport = () => {
    const htmlContent = generateHtmlReport();
    if (!htmlContent) return;

    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'reference-report.html';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const getConfidenceBadge = (confidence) => {
    if (confidence === 'User Confirmed') return 'bg-blue-100 text-blue-800';
    if (confidence >= 90) return 'bg-green-100 text-green-800';
    if (confidence >= 70) return 'bg-yellow-100 text-yellow-800';
    return 'bg-red-100 text-red-800';
  };

  const getConfidenceColor = (confidence) => {
    if (confidence >= 0.8) return 'text-green-600';
    if (confidence >= 0.6) return 'text-yellow-600';
    return 'text-red-600';
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
      <div className="max-w-6xl mx-auto">
        <div className="text-center mb-8">
          <div className="flex items-center justify-center mb-4">
            <span className="text-5xl text-indigo-600 mr-3">üìÑ</span>
            <h1 className="text-4xl font-bold text-gray-800">Academic Reference Checker</h1>
          </div>
          <p className="text-lg text-gray-600">
            Automatically verify citations and reference lists in academic documents
          </p>
        </div>

        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
          <div className="mb-6">
            <label htmlFor="text-input" className="block text-sm font-medium text-gray-700 mb-2">
              Paste Document Text
            </label>
             <div className="mt-2 mb-4">
                <label htmlFor="docx-file-input" className="text-sm font-medium text-gray-700">Or upload a .docx file:</label>
                <input 
                    type="file" 
                    id="docx-file-input" 
                    accept=".docx" 
                    onChange={handleFileSelect}
                    className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"
                />
            </div>
            <textarea
              id="text-input"
              value={documentText}
              onChange={(e) => setDocumentText(e.target.value)}
              placeholder="Paste your academic document here... or upload a .docx file."
              className="w-full h-64 p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none"
            />
          </div>

          <button
            onClick={() => processDocument()}
            disabled={!documentText.trim() || isProcessing}
            className="w-full bg-indigo-600 text-white py-3 px-6 rounded-lg hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors flex items-center justify-center space-x-2"
          >
            {isProcessing ? (
              <>
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                <span>Processing Document...</span>
              </>
            ) : (
              <>
                <span className="text-xl">üîç</span>
                <span>Analyze References</span>
              </>
            )}
          </button>
        </div>

        {results && (
          <div className="space-y-6">
            <div className="bg-white rounded-xl shadow-lg p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-2xl font-bold text-gray-800">Analysis Summary</h2>
                <div className="flex space-x-2">
                  {results && results.unused.length > 0 && results.missing.length > 0 && !lenientMatches && (
                    <button
                      onClick={runLenientAnalysis}
                      disabled={isLenientAnalysisRunning}
                      className="flex items-center space-x-2 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 disabled:bg-gray-400 transition-colors"
                    >
                      {isLenientAnalysisRunning ? (
                        <>
                          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                          <span>Analyzing...</span>
                        </>
                      ) : (
                        <>
                          <span className="text-lg">üîÑ</span>
                          <span>Find Lenient Matches</span>
                        </>
                      )}
                    </button>
                  )}
                  <button
                    onClick={downloadHtmlReport}
                    className="flex items-center space-x-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors"
                  >
                    <span className="text-lg">üì•</span>
                    <span>Download HTML Report</span>
                  </button>
                </div>
              </div>
              
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
                <div className="bg-blue-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-blue-600">{results.summary.totalCitations}</div>
                  <div className="text-sm text-gray-600">Total Citations</div>
                </div>
                <div className="bg-emerald-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-emerald-600">{results.summary.fullMatches}</div>
                  <div className="text-sm text-gray-600">Full Matches</div>
                </div>
                <div className="bg-green-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-green-600">{results.summary.partialMatches}</div>
                  <div className="text-sm text-gray-600">Partial Matches</div>
                </div>
                <div className="bg-red-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-red-600">{results.summary.missingReferences}</div>
                  <div className="text-sm text-gray-600">Missing Refs</div>
                </div>
                <div className="bg-orange-50 p-4 rounded-lg text-center">
                  <div className="text-2xl font-bold text-orange-600">{results.summary.unusedReferences}</div>
                  <div className="text-sm text-gray-600">Unused Refs</div>
                </div>
              </div>
            </div>

            {lenientMatches && lenientMatches.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center">
                    <span className="text-2xl text-purple-500 mr-2">üîÑ</span>
                    <h3 className="text-xl font-bold text-gray-800">Lenient Match Suggestions ({lenientMatches.length})</h3>
                  </div>
                </div>
                <div className="space-y-4">
                  {lenientMatches.map((suggestion, index) => (
                    <div key={index} className="border rounded-lg p-4 bg-purple-50 border-purple-200">
                      <div className="font-semibold text-gray-800 mb-2">
                        Unused Reference: <span className="font-normal">{suggestion.reference.original}</span>
                      </div>
                      <div>
                        <div className="text-sm font-medium text-gray-700 mb-2">Potential matches with missing citations:</div>
                        {suggestion.candidates.map((candidate, candIndex) => (
                          <div key={candIndex} className="mb-2 p-2 bg-white border rounded">
                            <div className="flex items-center justify-between">
                              <div className="flex-1">
                                <div className="text-sm font-mono bg-gray-100 p-2 rounded italic">
                                  "{candidate.citation.original}"
                                </div>
                                <div className="text-xs mt-1">
                                  Match on: {candidate.citation.authors} ({candidate.citation.year})
                                </div>
                              </div>
                              <div className="flex flex-col space-y-1 ml-4">
                                <button
                                  onClick={() => confirmLenientMatch(suggestion, candidate.citation)}
                                  className="px-3 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600 transition-colors"
                                >
                                  Confirm Match
                                </button>
                                <button
                                  onClick={() => dismissLenientSuggestion(suggestion, candidate)}
                                  className="px-3 py-1 bg-gray-400 text-white text-xs rounded hover:bg-gray-500 transition-colors"
                                >
                                  Dismiss
                                </button>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.missing.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <span className="text-2xl text-red-500 mr-2">‚ö†Ô∏è</span>
                  <h3 className="text-xl font-bold text-gray-800">Missing References ({results.missing.length})</h3>
                </div>
                <div className="space-y-4">
                  {results.missing.map((item, index) => (
                    <div key={index} className="border border-red-200 rounded-lg p-4 bg-red-50">
                      <div className="font-semibold text-red-800 mb-2">
                        Citation: {item.citation.original}
                      </div>
                      <div className="text-sm text-gray-600 mb-2">
                        Authors: {item.citation.authors} | Year: {item.citation.year}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.fullMatches.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <span className="text-2xl text-emerald-500 mr-2">‚úÖ</span>
                  <h3 className="text-xl font-bold text-gray-800">Full Matches ({results.fullMatches.length})</h3>
                </div>
                <div className="space-y-3">
                  {results.fullMatches.map((item, index) => (
                    <div key={index} className="border border-emerald-200 rounded-lg p-4 bg-emerald-50">
                      <div className="flex items-center justify-between">
                        <div className="flex-1">
                          <div className="font-semibold text-emerald-800">
                            Citation: {item.citation.original}
                          </div>
                          <div className="text-sm text-gray-600 mt-1">
                            Matches: {item.reference.original}
                            <a href={`https://www.google.com/search?q=${encodeURIComponent(item.reference.original)}`} target="_blank" rel="noopener noreferrer" className="text-xs text-blue-600 hover:underline ml-2">
                              (Search Google)
                            </a>
                          </div>
                        </div>
                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${getConfidenceBadge(item.confidence)}`}>
                          {item.confidence}% confidence
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.partialMatches.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <span className="text-2xl text-green-500 mr-2">‚úÖ</span>
                  <h3 className="text-xl font-bold text-gray-800">Partial Matches ({results.partialMatches.length})</h3>
                </div>
                <div className="space-y-3">
                  {results.partialMatches.map((item, index) => (
                    <div key={index} className="border border-green-200 rounded-lg p-4 bg-green-50">
                      <div className="flex items-center justify-between">
                        <div className="flex-1">
                          <div className="font-semibold text-green-800">
                            Citation: {item.citation.original}
                          </div>
                          <div className="text-sm text-gray-600 mt-1">
                            Matches: {item.reference.original}
                            <a href={`https://www.google.com/search?q=${encodeURIComponent(item.reference.original)}`} target="_blank" rel="noopener noreferrer" className="text-xs text-blue-600 hover:underline ml-2">
                              (Search Google)
                            </a>
                          </div>
                        </div>
                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${getConfidenceBadge(item.confidence)}`}>
                          {item.confidence === 'User Confirmed' ? 'User Confirmed' : `${item.confidence}% confidence`}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {results.unused.length > 0 && (
              <div className="bg-white rounded-xl shadow-lg p-6">
                <div className="flex items-center mb-4">
                  <span className="text-2xl text-orange-500 mr-2">‚ö†Ô∏è</span>
                  <h3 className="text-xl font-bold text-gray-800">Unused References ({results.unused.length})</h3>
                </div>
                <div className="space-y-4">
                  {results.unused.map((item, index) => (
                    <div key={index} className="border border-orange-200 rounded-lg p-4 bg-orange-50">
                      <div className="font-semibold text-orange-800 mb-2">
                        {item.reference.original}
                        <a href={`https://www.google.com/search?q=${encodeURIComponent(item.reference.original)}`} target="_blank" rel="noopener noreferrer" className="text-xs text-blue-600 hover:underline ml-2">
                          (Search Google)
                        </a>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

ReactDOM.render(<ReferenceChecker />, document.getElementById('root'));
    </script>
</body>
</html>
